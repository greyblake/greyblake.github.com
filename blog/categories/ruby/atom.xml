<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Sergey Potapov]]></title>
  <link href="http://greyblake.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://greyblake.com/"/>
  <updated>2013-12-20T20:22:04+02:00</updated>
  <id>http://greyblake.com/</id>
  <author>
    <name><![CDATA[Sergey Potapov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to compare audio in ruby]]></title>
    <link href="http://greyblake.com/blog/2013/12/19/how-to-compare-audio-in-ruby/"/>
    <updated>2013-12-19T19:51:00+02:00</updated>
    <id>http://greyblake.com/blog/2013/12/19/how-to-compare-audio-in-ruby</id>
    <content type="html"><![CDATA[<h2>Or how to implement sound_like RSpec matcher</h2>

<p>The problem I'm trying to solve in this article is comparison of two
audio files. We'll figure out how to verify that they sound similar.</p>

<p>I was developing an application that has a deal with audio processing and
I had to write a test to verify outcome audio file matches a one
from fixtures. Well, I've decided to compare audio binaries like these:</p>

<p><code>ruby
expect(File.read('outcome.mp3')).to eq File.read('fixture.mp3')
</code></p>

<p>And it worked!</p>

<p>But soon my colleagues let me know I had broken the build. It turned out
that <code>outcome.mp3</code>generated on their Mac books didn't match <code>fixture.mp3</code>
generated on my linux laptop, despite the fact that both sounded
absolutely the same. Probably we had different codecs.
So I had to come up with a better idea.</p>

<h2>Audio fingerprints and Chromaprint</h2>

<p>After some investigation I found a term "audio fingerprint" or "acoustic fingerprint",
it was exactly what I was looking for. From Wikipedia:</p>

<blockquote><p>An acoustic fingerprint is a condensed digital summary, deterministically generated
from an audio signal, that can be used to identify an audio sample or quickly locate
similar items in an audio database</p></blockquote>

<p>It's used by services like Shazam to identify songs.</p>

<p>So I started looking for open source implementations and found
<a href="http://acoustid.org/chromaprint">Chromaprint</a> - a C library that calculates audio fingerprints
from raw audio files. It seemed to be simple, with good source documentation
and easy to get started.</p>

<h2>Integrate Chromaprint with Ruby</h2>

<p>I found no already existing bindings, so I've implemented
<a href="https://github.com/TMXCredit/chromaprint">my own</a>. Instead of using C,
I gave <a href="https://github.com/ffi/ffi">FFI</a> a shot and it worked perfect!
As result I had stuff that worked the following way:</p>

<p><code>ruby
context     = Chromaprint::Context.new(44100, 1)
fingerprint = context.get_fingerprint(raw_audio_data)
fingerprint.raw # =&gt; [294890785, 328373552, 315802880, 303481088, ...]
</code></p>

<p>According to Chromaprint's documentation a raw fingerprint is an array of 4 byte integers.
But how to compare to 2 fingerprints to detect similarity?</p>

<h2>Hamming distance</h2>

<p>The answer was to calculate Hamming distance from binary representation of fingerprints.
Again according to Wikipedia:</p>

<blockquote><p>In information theory, the Hamming distance between two strings of equal length is
the number of positions at which the corresponding symbols are different. In another
way, it measures the minimum number of substitutions required to change one string
into the other, or the minimum number of errors that could have transformed one
string into the other.</p></blockquote>

<p>To calculate Hamming distance for binary data we need to apply XOR operation and count
number of 1 in the result.</p>

<p>Here is a small example for 2 byte values:</p>

<pre><code>dec     bin
11737   00101101 11011001
27129   01101001 11111001

XOR     01000100 00100000

Hamming distance is 3
</code></pre>

<p>Basing on this I implemented an additional method <code>Fingerprint#compare(fingerprint)</code>
that calculates similarity in range from 0 to 1.</p>

<h2>Create RSpec matcher</h2>

<p>Now I could compare raw audio data, but in real world almost always we have to have a deal
with compressed audio like mp3 or ogg. However wav files contain exactly raw audio data.
So I could convert compressed audio to wav, then read it to get raw audio and
calculate fingerprints for comparison. To convert audio I prefer using <code>sox</code>
command line tool, it's pretty powerful.</p>

<p>I have to explain that I did it all to avoid having a deal with
audio codecs within ruby, since it would make things be much more complicated.</p>

<p>Finally I got <code>sound_like</code> RSpec matcher:</p>

<p>```ruby</p>

<h1>Compare sound of two audio files.</h1>

<h1>Based on the Chromaprint library and the +sox+ command like tool.</h1>

<p>#</p>

<h1>@example</h1>

<h1>"/Airborne.mp3".should sound_like "/ACDC.mp3"</h1>

<h1>"/Children_of_Bodom.mp3".should_not sound_like "/Britney_Spears.mp3"</h1>

<p>RSpec::Matchers.define :sound_like do |expected_file|
  match do |file|</p>

<pre><code>rate      = 96000
channels  = 1
threshold = 0.95

if File.exists?(expected_file) &amp;&amp; File.exists?(file)
  # Convert input files into raw 16-bit signed audio (WAV) to
  # process with Chromaprint:
  sox_command    = "sox %s -e signed -b 16 -t wav - " \
                   "rate #{rate} channels #{channels} 2&gt; /dev/null"
  expected_audio = %x"#{sox_command % [expected_file]}"
  audio          = %x"#{sox_command % [file]}"

  # Get audio fingerprints:
  chromaprint = Chromaprint::Context.new(rate, channels)
  expected_fp = chromaprint.get_fingerprint(expected_audio)
  fp          = chromaprint.get_fingerprint(audio)

  # Compare fingerprints and compare result against threshold:
  expected_fp.compare(fp) &gt; threshold
else
  false
end
</code></pre>

<p>  end
end
```</p>

<p>Note that I used threshold with value 0.95 because quite rare fingerprints
have 100% match.</p>

<h2>Links</h2>

<ul>
<li><a href="https://github.com/TMXCredit/chromaprint">Chromaprint ruby port on github</a></li>
<li><a href="http://acoustid.org/chromaprint">Chromaprint web page</a></li>
<li><a href="http://en.wikipedia.org/wiki/Acoustic_fingerprint">Acoustic fingerprint in Wikipedia</a></li>
<li><a href="http://en.wikipedia.org/wiki/Hamming_distance">Hamming distance in Wikipedia</a></li>
<li><a href="http://stackoverflow.com/a/6397116/1013173">Most efficient way to calculate Hamming distance in ruby</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to call bash(not shell) from ruby]]></title>
    <link href="http://greyblake.com/blog/2013/09/21/how-to-call-bash-not-shell-from-ruby/"/>
    <updated>2013-09-21T21:53:00+03:00</updated>
    <id>http://greyblake.com/blog/2013/09/21/how-to-call-bash-not-shell-from-ruby</id>
    <content type="html"><![CDATA[<p>Few days ago I was writing a ruby wrapper for <a href="http://sox.sourceforge.net/">SoX</a>
command line tool. To reduce disk IO I wanted to use <a href="http://en.wikipedia.org/wiki/Process_substitution">process substitution</a>.
It's a cool shell feature which allows to use command output as an input file for another command.
It's pretty useful if the second command doesn't work with standard input or you need
to pass more than 1 input.</p>

<p>Let me show the classic example(works in bash and zsh):</p>

<p>```bash
cat &lt;(echo 'Saluton!') &lt;(echo 'Kiel vi fartas?')</p>

<h1>=> Saluton! Kiel vi fartas?</h1>

<p>```</p>

<p>So statement <code>&lt;(echo 'Saluton!')</code> is treated like a file which contains line <code>Saluton!</code>.
Underhood bash(zsh) creates a named pipeline where output of <code>echo 'Saluton!'</code> is written.
Then the named pipeline is passed to <code>cat</code> command.</p>

<p>You can see it:</p>

<p>```bash
echo  &lt;(echo 'Saluton!')</p>

<h1>=> /dev/fd/63</h1>

<p>```</p>

<p>So I wanted to use it in ruby:
<code>ruby
cmd = "cat &lt;(echo 'Saluton!') &lt;(echo 'Kiel vi fartas?')"
system(cmd)
</code></p>

<p>But unfortunately it doesn't work:
<code>
sh: 1: Syntax error: "(" unexpected
</code></p>

<p>The problem is that ruby's <code>system</code> method and back quotes use<code>sh</code>
not your current shell (which in my case is <code>bash</code>).</p>

<p>```ruby
system "echo $0"</p>

<h1>=> sh</h1>

<p>```</p>

<p>In shells <code>$0</code>points to the current script or to interpreter if you're running it interactively.</p>

<p>Fortunately there is a way to create a workaround to run bash:</p>

<p>```ruby
require 'shellwords'</p>

<p>def bash(command)
  escaped_command = Shellwords.escape(command)
  system "bash -c #{escaped_command}"
end
```</p>

<p>Bash has option <code>-c</code> which takes bash script to execute.
<a href="http://www.ruby-doc.org/stdlib-2.0/libdoc/shellwords/rdoc/Shellwords.html">Shellwords</a>
is a standard ruby library which provides a method to escape shell commands.</p>

<p>So now it works as we want it to be:</p>

<p><code>ruby
bash("echo $0")  # =&gt; bash
cmd = "cat &lt;(echo 'Saluton!') &lt;(echo 'Kiel vi fartas?')"
bash(cmd)        # =&gt; Saluton! Kiel vi fartas?
</code></p>

<p>Thanks for reading!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Validation in rails with Themis]]></title>
    <link href="http://greyblake.com/blog/2013/08/19/validation-in-rails-with-themis/"/>
    <updated>2013-08-19T17:21:00+03:00</updated>
    <id>http://greyblake.com/blog/2013/08/19/validation-in-rails-with-themis</id>
    <content type="html"><![CDATA[<p>Sometimes ActiveRecord is not enough to meet complicated validation needs.
At <a href="http://tmxcredit.com/">TMXCredit</a> we've created <a href="https://github.com/TMXCredit/themis">Themis</a> -
ActiveRecord extension which helps to organize validations in a better way and adds
some flexibility. Here I'm gonna describe some problems which Themis solves after that
I'll take a brief look at possible alternative solutions.</p>

<h2>Modular validation</h2>

<p>Themis allows you to extract duplicated validations into module for reuse.
Usually rails applications are small enough so you don't need it. But sometimes
you do.</p>

<p>The next example is pretty flat(in real life you probably would use STI or composition to
represent <code>Doctor</code> and <code>Patient</code> models) but it illustrates where Themis could be useful.</p>

<p>Let's say you have 2 models:</p>

<p>```ruby
class Doctor &lt; ActiveRecord::Base
  validates :first_name, :last_name, :email, :diploma,</p>

<pre><code>        :presence =&gt; true
</code></pre>

<p>end</p>

<p>class Patient &lt; ActiveRecord::Base
  validates :first_name, :last_name, :email, :age,</p>

<pre><code>        :presence =&gt; true
</code></pre>

<p>end
```</p>

<p>You see that both models have the same validation for <code>first_name</code>, <code>last_name</code> and <code>email</code>.</p>

<p>Themis allows you to fix the duplication problem by extracting common validations into
a module:</p>

<p>```ruby</p>

<h1>Module with common validations.</h1>

<p>module PersonValidation
  extend Themis::Validation</p>

<p>  validates :first_name, :last_name, :email, :presence => true
end</p>

<p>class Doctor &lt; ActiveRecord::Base
  # import validation of first_name, last_name, email
  include PersonValidation</p>

<p>  validates :diploma, :presence => true
end</p>

<p>class Patient &lt; ActiveRecord::Base
  include PersonValidation</p>

<p>  validates :age, :presence => true
end
```</p>

<!--more-->


<p>So now we keep the common validation in one place.
If you want, you can include validation modules into each other to combine
necessary validation.</p>

<h2>Validation scenarios</h2>

<p>Here is another problem which Themis solves.</p>

<p>We have the following models:</p>

<p>```ruby
class User &lt; ActiveRecord::Base
  has_one :person
  has_many :user_accounts
end</p>

<p>class Person &lt; ActiveRecord::Base
  attr_accessible :first_name, :last_name, :birhday</p>

<p>  belongs_to :user
end</p>

<p>class UserAccount &lt; ActiveRecord::Base
  attr_accessible :email, :login</p>

<p>  belongs_to :user
end
```</p>

<p>So we have a model graph like this with <code>User</code> model on the top:</p>

<p><img src="http://i1078.photobucket.com/albums/w484/greyblake/themis_model_graph.png" alt="Themis - model graph" /></p>

<p>It's pretty small, but in real life the graph can be much deeper.</p>

<p>What would you do if you needed to apply different validations depending on context?
For example according to your business requirements users must be allowed to use
your application only in case if they've filled in all of the fields.
So you need to validate presense of <code>first_name</code>, <code>last_name</code> and <code>birhday</code>
on <code>Person</code> model and <code>email</code>, <code>login</code> and <code>password</code> on <code>UserAccount</code>.</p>

<p>It's not a problem, just add the validations to appropriate models:</p>

<p>```ruby
class Person &lt; ActiveRecord::Base
  validates :first_name, :layout, :birhday, :presence => true
end</p>

<p>class UserAccount &lt; ActiveRecord::Base
  validates :email, :login, :presence => true
end
```</p>

<p>There is some percent of users who don't finish registration process.
But your marketing department wants to have an ability to contact them
if they have entered an email address.</p>

<p>So that's where the issue is: you can't save records using validation rules written above.</p>

<p>With Themis you can declare number of validation strategies,
and depending on context, chose which one you need.</p>

<p>Here is how a complete solution looks:</p>

<p>```ruby
class User &lt; ActiveRecord::Base
  has_one :person
  has_many :user_accounts</p>

<p>  accepts_nested_attributes_for :person, :user_accounts</p>

<p>  # Declare validations. Use :full as default.
  has_validation :full, :default => true
  has_validation :partial
end</p>

<p>class Person &lt; ActiveRecord::Base
  attr_accessible :first_name, :last_name, :birhday</p>

<p>  belongs_to :user</p>

<p>  # Declare full validation
  has_validation :full do |model|</p>

<pre><code>model.validates :first_name, :last_name, :birhday, :presence =&gt; true
</code></pre>

<p>  end</p>

<p>  # Delcare partial validation. Nothing to validate.
  has_validation :partial
end</p>

<p>class UserAccount &lt; ActiveRecord::Base
  attr_accessible :email, :login</p>

<p>  has_validation :full do |model|</p>

<pre><code>model.validates :login, :email, :presence =&gt; true
</code></pre>

<p>  end</p>

<p>  has_validation :partial do |model|</p>

<pre><code>model.validates :email, :presence =&gt; true
</code></pre>

<p>  end
end
```</p>

<p>And here is how you would use it somewhere in a controller:</p>

<p>```ruby</p>

<h1>Create model initialized with params</h1>

<p>user = User.new(
  :person => {</p>

<pre><code>:first_name =&gt; "Alex",
:last_name  =&gt; "DeLarge",
:birhday    =&gt; "1962"
</code></pre>

<p>  },
  :user_accounts => [{</p>

<pre><code>:email =&gt; "clockwork@orange.com"
</code></pre>

<p>  }]
)</p>

<p>user.valid? # => false, because login is missing</p>

<h1>Try to apply partial validation</h1>

<p>user.use_validation(:partial)
user.valid? # => true</p>

<h1>We can save it</h1>

<p>user.save!
```</p>

<h2>Alternative solutions</h2>

<p>If you think Themis is overkill for your project, you still have some options.</p>

<h3>Using ActiveSupport::Concern for modularity</h3>

<p><code>ActiveSupport::Concern</code> is another way which allows to extract common validations
into module. Here how would <code>PersonValidation</code> module described above could look:</p>

<p>```ruby
module PersonValidation
  extend ActiveSupport::Concern</p>

<p>  included do</p>

<pre><code>validates :first_name, :last_name, :email, :presence =&gt; true
</code></pre>

<p>  end
end</p>

<p>```</p>

<h3>Using conditional validation</h3>

<p>If your requirements aren't so fancy, you can be satisfied with a simple
conditional validation, e. g.</p>

<p>```ruby
class Person &lt; ActiveRecord::Base
  validates :first_name, :last_name, :birhday, :presence => true,</p>

<pre><code>        :if =&gt; :use_full_validation?
</code></pre>

<p>  # Lets add one more validation statement(for the next example)
  validates :first_name, :last_name, :length => { :maximum => 255 },</p>

<pre><code>        :if =&gt; :use_full_validation?
</code></pre>

<p>  def use_full_validation?</p>

<pre><code># Some logic goes here
</code></pre>

<p>  end
end
```</p>

<p>To DRY up <code>:if</code> options it's good to use <code>with_options</code> method:</p>

<p>```ruby
class Person &lt; ActiveRecord::Base
  with_options :if => :use_full_validation? do |person|</p>

<pre><code>person.validates :first_name, :last_name, :birhday, :presence =&gt; true
person.validates :first_name, :last_name, :length =&gt; { :maximum =&gt; 255 }
</code></pre>

<p>  end
end
```</p>

<p>Now <code>:if =&gt; :use_full_validation</code> will be additonaly passed to every method call
on <code>person</code> inside the block.</p>

<h3>Vanguard</h3>

<p>The guys from <a href="http://rom-rb.org/">the ROM project</a> have their own validator called
<a href="https://github.com/mbj/vanguard">Vanguard</a>(previous name is Aqeuitas).
The sweet thing about it is that it allows to seperate validations and
models according to DataMapper approach. The downside is if you use ActiveRecord
you'll have a zoo of validation tools. Also it may be still raw and I'm not sure
is it possible to apply it to solve the described problem, but I'd encourage
you to take a look at it.</p>

<h2>Conclusion</h2>

<p>ActiveRecord is good for plain and straightforward projects.
In big enterprise applications usually we need more flexibility to meet different
exotic requiments.
We've created <a href="https://github.com/TMXCredit/themis">Themis</a> to extend ActiveRecord
and solve some of the problems.
Actually I hope that <a href="http://rom-rb.org/">ROM</a> will be ready soon and we'll
have an ability to select right ORM before diving into development.</p>

<p>Thanks for reading. Hope the article was useful for you and I'm wating for
your feedback!</p>

<h2>Links</h2>

<ul>
<li><a href="https://github.com/TMXCredit/themis">Themis on Github</a> - you'll find here comprehensive documentation in README;</li>
<li><a href="http://guides.rubyonrails.org/active_record_validations.html#conditional-validation">Conditional validation</a> - extraction from Rails Guide;</li>
<li><a href="https://github.com/mbj/vanguard">Vanguard on Github</a> - validator for ROM project;</li>
<li><a href="http://railscasts.com/episodes/42-with-options">Railscast: #42</a> - Ryan Bates describes how <code>with_options</code> works.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rational can't be coerced into BigDecimal in ruby 1.9.3]]></title>
    <link href="http://greyblake.com/blog/2012/12/20/rational-cant-be-coerced-into-bigdecimal-in-ruby-1-dot-9-3/"/>
    <updated>2012-12-20T16:34:00+02:00</updated>
    <id>http://greyblake.com/blog/2012/12/20/rational-cant-be-coerced-into-bigdecimal-in-ruby-1-dot-9-3</id>
    <content type="html"><![CDATA[<p>Trying to move a rails application from ruby 1.8.7 to 1.9.3 I ran into coercion
issue of <code>Rational</code> class.</p>

<p>Ruby 1.9.3:
```ruby
require 'bigdecimal'
require 'rational'</p>

<h1>You can multiply Rational against BigDecimal</h1>

<p>Rational(1) * BigDecimal('1')  # => &lt;BigDecimal:a566d0,'0.1E1',9(36)></p>

<h1>But you can't do the same when you change order</h1>

<p>BigDecimal('1') * Rational(1)  # => TypeError: Rational can't be coerced into BigDecimal
```</p>

<p>On other hand in Ruby 1.8.7:</p>

<p>```ruby
require 'bigdecimal'
require 'rational'</p>

<h1>BigDecimal * Rational works OK</h1>

<p>BigDecimal('1') * Rational(1)  # => 1.0 (Float)</p>

<h1>But Rational * BigDecimal doesn't</h1>

<p>Rational(1) * BigDecimal('1')  # => TypeError: Rational can't be coerced into BigDecimal
```</p>

<p>It's looks weird. So I can only say for sure that <code>Rational</code> -> <code>BigDecimal</code>
coercion is not implemented in Ruby.</p>

<p>I've tried to fix it with simple monkey patch:</p>

<p>```ruby</p>

<h1>Works only for Ruby1.9.3</h1>

<p>class Rational
  def coerce(value)</p>

<pre><code>case value
when BigDecimal
  return self, value
else
  super
end
</code></pre>

<p>  end
end
```</p>

<p>And it works OK against simple examples:</p>

<p><code>ruby
Rational(1) * BigDecimal('1')  # =&gt; &lt;BigDecimal:a566d0,'0.1E1',9(36)&gt;
BigDecimal('1') * Rational(1)  # =&gt; &lt;BigDecimal:a566d0,'0.1E1',9(36)&gt;
</code></p>

<p>But it causes intermittent segmentation faults when I run Rails application.</p>

<p>Any ideas about the coercion? Is it expected behaviour of ruby1.9.3?
I found no bugs reported this issue on
<a href="bugs.ruby-lang.org">https://bugs.ruby-lang.org</a>.</p>

<p>I'll appreciate any feedback. Thanks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Custom expectations with RSpec]]></title>
    <link href="http://greyblake.com/blog/2012/12/14/custom-expectations-with-rspec/"/>
    <updated>2012-12-14T00:34:00+02:00</updated>
    <id>http://greyblake.com/blog/2012/12/14/custom-expectations-with-rspec</id>
    <content type="html"><![CDATA[<p>I know you love RSpec's <code>expect</code> DSL like this:</p>

<p><code>ruby
expect { raise("Boom!") }.to raise_error(RuntimeError, "Boom!")
</code></p>

<p>We often write our own custom matchers and I wanna show how is easy to write
custom expectation.</p>

<h2>Desired DSL</h2>

<p>Usually when I do things like this I start with DSL. I think it's important since
it must be convenient to use and easy to read.
So turn on your imagination and spend some time on it.</p>

<p>In my example I'm gonna create an expectation to test text written to standard output
and standard error.
There are samples how I wanna use it(desired DSL):</p>

<p>```ruby</p>

<h1>Test text written to standard output</h1>

<p>expect { puts "Hello!" }.to write("Hello!")</p>

<h1>Test text written to standard error</h1>

<p>expect { warn "Stop it!" }.to write("Stop it!").to(:error)
```</p>

<!--more-->


<h2>Expectation</h2>

<p>I bet you've already created number of custom matchers. What about custom expectations?
They are usual custom matches which test blocks of code!</p>

<p>I'm gonna locate the expectation in <code>spec/support/custom_expectations/write_expectation.rb</code> file.
I think <code>spec/support/custom_expectations/</code> directory is the right place for it since
custom matchers usually are located in <code>spec/support/custom_matchers/</code>.</p>

<p>So finally the expectation looks this way:</p>

<p>```ruby spec/support/custom_expectations/write_expectation.rb
RSpec::Matchers.define :write do |message|
  chain(:to) do |io|</p>

<pre><code>@io = io
</code></pre>

<p>  end</p>

<p>  match do |block|</p>

<pre><code>output =
  case io
  when :output then fake_stdout(&amp;block)
  when :error  then fake_stderr(&amp;block)
  else raise("Allowed values for `to` are :output and :error, got `#{io.inspect}`")
  end
output.include? message
</code></pre>

<p>  end</p>

<p>  description do</p>

<pre><code>"write \"#{message}\" #{io_name}"
</code></pre>

<p>  end</p>

<p>  failure_message_for_should do</p>

<pre><code>"expected to #{description}"
</code></pre>

<p>  end</p>

<p>  failure_message_for_should_not do</p>

<pre><code>"expected to not #{description}"
</code></pre>

<p>  end</p>

<p>  # Fake STDERR and return a string written to it.
  def fake_stderr</p>

<pre><code>original_stderr = $stderr
$stderr = StringIO.new
yield
$stderr.string
</code></pre>

<p>  ensure</p>

<pre><code>$stderr = original_stderr
</code></pre>

<p>  end</p>

<p>  # Fake STDOUT and return a string written to it.
  def fake_stdout</p>

<pre><code>original_stdout = $stdout
$stdout = StringIO.new
yield
$stdout.string
</code></pre>

<p>  ensure</p>

<pre><code>$stdout = original_stdout
</code></pre>

<p>  end</p>

<p>  # default IO is standard output
  def io</p>

<pre><code>@io ||= :output
</code></pre>

<p>  end</p>

<p>  # IO name is used for description message
  def io_name</p>

<pre><code>{:output =&gt; "standard output", :error =&gt; "standard error"}[io]
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>And that's it. You can try it against the examples from "Desired DSL" section.</p>

<p>Hope that's was useful. I look forward for your comments and suggestions. You know I do! =)</p>
]]></content>
  </entry>
  
</feed>
