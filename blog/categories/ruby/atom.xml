<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Sergey Potapov]]></title>
  <link href="http://greyblake.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://greyblake.com/"/>
  <updated>2013-01-27T22:30:15+02:00</updated>
  <id>http://greyblake.com/</id>
  <author>
    <name><![CDATA[Sergey Potapov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rational can't be coerced into BigDecimal in ruby 1.9.3]]></title>
    <link href="http://greyblake.com/blog/2012/12/20/rational-cant-be-coerced-into-bigdecimal-in-ruby-1-dot-9-3/"/>
    <updated>2012-12-20T16:34:00+02:00</updated>
    <id>http://greyblake.com/blog/2012/12/20/rational-cant-be-coerced-into-bigdecimal-in-ruby-1-dot-9-3</id>
    <content type="html"><![CDATA[<p>Trying to move a rails application from ruby 1.8.7 to 1.9.3 I ran into coercion
issue of <code>Rational</code> class.</p>

<p>Ruby 1.9.3:
```ruby
require 'bigdecimal'
require 'rational'</p>

<h1>You can multiply Rational against BigDecimal</h1>

<p>Rational(1) * BigDecimal('1')  # => &lt;BigDecimal:a566d0,'0.1E1',9(36)></p>

<h1>But you can't do the same when you change order</h1>

<p>BigDecimal('1') * Rational(1)  # => TypeError: Rational can't be coerced into BigDecimal
```</p>

<p>On other hand in Ruby 1.8.7:</p>

<p>```ruby
require 'bigdecimal'
require 'rational'</p>

<h1>BigDecimal * Rational works OK</h1>

<p>BigDecimal('1') * Rational(1)  # => 1.0 (Float)</p>

<h1>But Rational * BigDecimal doesn't</h1>

<p>Rational(1) * BigDecimal('1')  # => TypeError: Rational can't be coerced into BigDecimal
```</p>

<p>It's looks weird. So I can only say for sure that <code>Rational</code> -> <code>BigDecimal</code>
coercion is not implemented in Ruby.</p>

<p>I've tried to fix it with simple monkey patch:</p>

<p>```ruby</p>

<h1>Works only for Ruby1.9.3</h1>

<p>class Rational
  def coerce(value)</p>

<pre><code>case value
when BigDecimal
  return self, value
else
  super
end
</code></pre>

<p>  end
end
```</p>

<p>And it works OK against simple examples:</p>

<p><code>ruby
Rational(1) * BigDecimal('1')  # =&gt; &lt;BigDecimal:a566d0,'0.1E1',9(36)&gt;
BigDecimal('1') * Rational(1)  # =&gt; &lt;BigDecimal:a566d0,'0.1E1',9(36)&gt;
</code></p>

<p>But it causes intermittent segmentation faults when I run Rails application.</p>

<p>Any ideas about the coercion? Is it expected behaviour of ruby1.9.3?
I found no bugs reported this issue on
<a href="bugs.ruby-lang.org">https://bugs.ruby-lang.org</a>.</p>

<p>I'll appreciate any feedback. Thanks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Custom expectations with RSpec]]></title>
    <link href="http://greyblake.com/blog/2012/12/14/custom-expectations-with-rspec/"/>
    <updated>2012-12-14T00:34:00+02:00</updated>
    <id>http://greyblake.com/blog/2012/12/14/custom-expectations-with-rspec</id>
    <content type="html"><![CDATA[<p>I know you love RSpec's <code>expect</code> DSL like this:</p>

<p><code>ruby
expect { raise("Boom!") }.to raise_error(RuntimeError, "Boom!")
</code></p>

<p>We often write our own custom matchers and I wanna show how is easy to write
custom expectation.</p>

<h2>Desired DSL</h2>

<p>Usually when I do things like this I start with DSL. I think it's important since
it must be convenient to use and easy to read.
So turn on your imagination and spend some time on it.</p>

<p>In my example I'm gonna create an expectation to test text written to standard output
and standard error.
There are samples how I wanna use it(desired DSL):</p>

<p>```ruby</p>

<h1>Test text written to standard output</h1>

<p>expect { puts "Hello!" }.to write("Hello!")</p>

<h1>Test text written to standard error</h1>

<p>expect { warn "Stop it!" }.to write("Stop it!").to(:error)
```</p>

<!--more-->


<h2>Expectation</h2>

<p>I bet you've already created number of custom matchers. What about custom expectations?
They are usual custom matches which test blocks of code!</p>

<p>I'm gonna locate the expectation in <code>spec/support/custom_expecations/write_expecation.rb</code> file.
I think <code>spec/support/custom_expecations/</code> directory is the right place for it since
custom matchers usually are located in <code>spec/support/custom_matchers/</code>.</p>

<p>So finally the expectation looks this way:</p>

<p>```ruby spec/support/custom_expecations/write_expecation.rb
RSpec::Matchers.define :write do |message|
  chain(:to) do |io|</p>

<pre><code>@io = io
</code></pre>

<p>  end</p>

<p>  match do |block|</p>

<pre><code>output =
  case io
  when :output then fake_stdout(&amp;block)
  when :error  then fake_stderr(&amp;block)
  else raise("Allowed values for `to` are :output and :error, got `#{io.inspect}`")
  end
output.include? message
</code></pre>

<p>  end</p>

<p>  description do</p>

<pre><code>"write \"#{message}\" #{io_name}"
</code></pre>

<p>  end</p>

<p>  failure_message_for_should do</p>

<pre><code>"expected to #{description}"
</code></pre>

<p>  end</p>

<p>  failure_message_for_should_not do</p>

<pre><code>"expected to not #{description}"
</code></pre>

<p>  end</p>

<p>  # Fake STDERR and return a string written to it.
  def fake_stderr</p>

<pre><code>original_stderr = $stderr
$stderr = StringIO.new
yield
$stderr.string
</code></pre>

<p>  ensure</p>

<pre><code>$stderr = original_stderr
</code></pre>

<p>  end</p>

<p>  # Fake STDOUT and return a string written to it.
  def fake_stdout</p>

<pre><code>original_stdout = $stdout
$stdout = StringIO.new
yield
$stdout.string
</code></pre>

<p>  ensure</p>

<pre><code>$stdout = original_stdout
</code></pre>

<p>  end</p>

<p>  # default IO is standard output
  def io</p>

<pre><code>@io ||= :output
</code></pre>

<p>  end</p>

<p>  # IO name is used for description message
  def io_name</p>

<pre><code>{:output =&gt; "standard output", :error =&gt; "standard error"}[io]
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>And that's it. You can try it against the examples from "Desired DSL" section.</p>

<p>Hope that's was useful. I look forward for your comments and suggestions. You know I do! =)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pg_power - ActiveRecord extension for PostgreSQL]]></title>
    <link href="http://greyblake.com/blog/2012/09/06/pg-power-activerecord-extension-for-postgresql/"/>
    <updated>2012-09-06T23:24:00+03:00</updated>
    <id>http://greyblake.com/blog/2012/09/06/pg-power-activerecord-extension-for-postgresql</id>
    <content type="html"><![CDATA[<p>I am happy to announce that  <a href="http://tmxcredit.com/">TMXCredit</a> released
<a href="https://github.com/TMXCredit/pg_power">pg_power</a> gem - an ActiveRecord extension which
allows to use number of PostgreSQL features with Rails.</p>

<h2>What you can do with pg_power?</h2>

<ul>
<li>Use PostgresSQL schemas in your Rails project.</li>
<li>Add comments to PostgreSQL database with Rails migrations.</li>
<li>Use foreign keys (we imported foreigner functionality and made it schema aware).</li>
<li>Use partial indexes.</li>
<li>Add indexes concurrently.</li>
</ul>


<p>You'll find enough documentation in <a href="https://github.com/TMXCredit/pg_power/blob/master/README.markdown">README</a>
file.</p>

<h2>Quick usage example</h2>

<p>Assume you want to create tables <code>countries</code> and <code>languages</code> in <code>demography</code> schema.</p>

<p>At first we need to create <code>demography</code> schema:</p>

<p>```ruby db/migrate/create_demography_schema.rb
class CreateDemographySchema &lt; &lt; ActiveRecord::Migration
  def change</p>

<pre><code>create_schema 'demography'
</code></pre>

<p>  end
end
```</p>

<p>Now let's create tables:</p>

<p>```ruby db/migrate/create_demography_languages.rb
class CreateDemographyLanguages &lt; ActiveRecord::Migration
  def change</p>

<pre><code># Create table `languages` in schema `demography`
create_table "languages", :schema =&gt; "demography" do |t|
  t.string :name
  t.string :code, :limit =&gt; 2
end

# Add PostgreSQL comments
set_table_comment "demography.languages", "List of languages"
set_column_comments "demography.languages",
    :name =&gt; "Full name of language in English",
    :code =&gt; "ISO 639-1 code"
</code></pre>

<p>  end
end
```</p>

<p>```ruby db/migrate/create_demography_countries.rb
class CreateDemographyContries &lt; ActiveRecord::Migration
  def change</p>

<pre><code># Create table `countries` in schema `demography`
create_table "countries", :schema =&gt; "demography" do |t|
  t.string :name

  # In real life you likely would have many-to-many associaton
  t.integer :language_id
end

# Add PostgreSQL comments
set_table_comment "demography.countries", "List of world countries"
set_column_comments "demography.languages",
    :name        =&gt; "Full name of country in English",
    :language_id =&gt; "Most popular language in the country"

# Add foreign key and create index on demography.countries.language_id
add_foreign_key("demography.countries", "demography.languages")
</code></pre>

<p>  end
end
```</p>

<p>Great! Now we need to set table names in models to make ActiveRecord know that
these tables are located in <code>demography</code> schema.</p>

<p><code>ruby app/models/language.rb
class Language &lt; ActiveRecord::Base
  set_table_name "demography.languages"
end
</code></p>

<p>It will work. But I would recommend you to create module <code>Demography</code> which would represent
<code>demography</code> schema and move those models to it. One more benefit is that you can define
schema prefix in module and models will use it build table name automatically.</p>

<p>```ruby app/models/demography.rb
module Demography
  def self.table_name_prefix</p>

<pre><code>'demography.'
</code></pre>

<p>  end
end
```</p>

<p><code>ruby app/models/demography/language.rb
module Demography::Language
  # No need to use set_table_name anymore
end
</code></p>

<p>I hope you will enjoy <a href="https://github.com/TMXCredit/pg_power">pg_power</a>. Let us know what you think!</p>

<p>Thanks. Sergey Potapov.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby performance tricks]]></title>
    <link href="http://greyblake.com/blog/2012/09/02/ruby-perfomance-tricks/"/>
    <updated>2012-09-02T23:34:00+03:00</updated>
    <id>http://greyblake.com/blog/2012/09/02/ruby-perfomance-tricks</id>
    <content type="html"><![CDATA[<p>I did some benchmarks to find out which alternatives to write code work faster. I wanna
share it with you. All benchmarks are made against ruby 1.9.3p194 MRI.</p>

<h2>Do not use exceptions for a control flow</h2>

<p>The next example is pretty stupid but it shows how exceptions slow against
conditional statements.</p>

<p>```ruby
require 'benchmark'</p>

<p>class Obj
  def with_condition</p>

<pre><code>respond_to?(:mythical_method) ? self.mythical_method : nil
</code></pre>

<p>  end</p>

<p>  def with_rescue</p>

<pre><code>self.mythical_method
</code></pre>

<p>  rescue NoMethodError</p>

<pre><code>nil
</code></pre>

<p>  end
end</p>

<p>obj = Obj.new
N = 10_000_000</p>

<p>puts RUBY_DESCRIPTION</p>

<p>Benchmark.bm(15, "rescue/condition") do |x|
  rescue_report     = x.report("rescue:")    { N.times { obj.with_rescue  } }
  condition_report  = x.report("condition:") { N.times { obj.with_if      } }
  [rescue_report / condition_report]
end
```</p>

<p>MRI 1.9.3:</p>

<pre><code>ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-linux]
                        user     system      total        real
rescue:           111.530000   2.650000 114.180000 (115.837103)
condition:          2.620000   0.010000   2.630000 (  2.633154)
rescue/condition:  42.568702 265.000000        NaN ( 43.991767)
</code></pre>

<p>MRI 1.8.7 (REE has similar result):</p>

<pre><code>ruby 1.8.7 (2011-12-28 patchlevel 357) [x86_64-linux]
                        user     system      total        real
rescue:            80.510000   0.940000  81.450000 ( 81.529022)
if:                 3.320000   0.000000   3.320000 (  3.330166)
rescue/condition:  24.250000        inf       -nan ( 24.481970)
</code></pre>

<!--more-->


<h2>String concatenation</h2>

<p>Avoid using <code>+=</code> to concatenate strings in favor of <code>&lt;&lt;</code> method.
The result is absolutely the same: add a string to the end of an existing one.
What is the difference then?</p>

<p>See the example:</p>

<p>```ruby
str1 = "first"
str2 = "second"
str1.object_id       # => 16241320</p>

<p>str1 += str2    # str1 = str1 + str2
str1.object_id  # => 16241240, id is changed</p>

<p>str1 &lt;&lt; str2
str1.object_id  # => 16241240, id is the same
```</p>

<p>When you use <code>+=</code> ruby creates a temporal object which is result of <code>str1 + str2</code>.
Then it overrides <code>str1</code> variable with reference to the new built object.
On other hand <code>&lt;&lt;</code> modifies existing one.</p>

<p>As a result of using <code>+=</code> you have the next disadvantages:</p>

<ul>
<li>More calculation to join strings.</li>
<li>Redundant string object in memory (previous value of <code>str1</code>), which approximates time when
<a href="http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29">GC</a> will trigger.</li>
</ul>


<p>How <code>+=</code> is slow? Basically it depends on length of strings you have operation with.</p>

<p>```ruby
require 'benchmark'</p>

<p>N = 1000
BASIC_LENGTH = 10</p>

<p>5.times do |factor|
  length = BASIC_LENGTH * (10 ** factor)
  puts "_" * 60 + "\nLENGTH: #{length}"</p>

<p>  Benchmark.bm(10, '+= VS &lt;&lt;') do |x|</p>

<pre><code>concat_report = x.report("+=")  do
  str1 = ""
  str2 = "s" * length
  N.times { str1 += str2 }
end

modify_report = x.report("&lt;&lt;")  do
  str1 = "s"
  str2 = "s" * length
  N.times { str1 &lt;&lt; str2 }
end

[concat_report / modify_report]
</code></pre>

<p>  end
end
```</p>

<p>Output:</p>

<pre><code>____________________________________________________________
LENGTH: 10
                 user     system      total        real
+=           0.000000   0.000000   0.000000 (  0.004671)
&lt;&lt;           0.000000   0.000000   0.000000 (  0.000176)
+= VS &lt;&lt;          NaN        NaN        NaN ( 26.508796)
____________________________________________________________
LENGTH: 100
                 user     system      total        real
+=           0.020000   0.000000   0.020000 (  0.022995)
&lt;&lt;           0.000000   0.000000   0.000000 (  0.000226)
+= VS &lt;&lt;          Inf        NaN        NaN (101.845829)
____________________________________________________________
LENGTH: 1000
                 user     system      total        real
+=           0.270000   0.120000   0.390000 (  0.390888)
&lt;&lt;           0.000000   0.000000   0.000000 (  0.001730)
+= VS &lt;&lt;          Inf        Inf        NaN (225.920077)
____________________________________________________________
LENGTH: 10000
                 user     system      total        real
+=           3.660000   1.570000   5.230000 (  5.233861)
&lt;&lt;           0.000000   0.010000   0.010000 (  0.015099)
+= VS &lt;&lt;          Inf 157.000000        NaN (346.629692)
____________________________________________________________
LENGTH: 100000
                 user     system      total        real
+=          31.270000  16.990000  48.260000 ( 48.328511)
&lt;&lt;           0.050000   0.050000   0.100000 (  0.105993)
+= VS &lt;&lt;   625.400000 339.800000        NaN (455.961373)
</code></pre>

<h2>Be careful with calculation within iterators</h2>

<p>Assume you need to write a function to convert an array into a hash
where keys and values are same as elements of the array:</p>

<p><code>ruby
func([1, 2, 3])  # =&gt; {1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3}
</code></p>

<p>The next solution would satisfy the requirements:</p>

<p><code>ruby
def func(array)
  array.inject({}) { |h, e| h.merge(e =&gt; e) }
end
</code>
And would be extremely slow with big portions of data because it contains
nested methods (<code>inject</code> and <code>merge</code>), so it's <strong> O(n<sup>2</sup>) </strong> algorithm.
But it's obviously that it must be <strong> O(n) </strong>.
Consider the next:</p>

<p><code>ruby
def func(array)
  array.inject({}) { |h, e| h[e] = e; h }
end
</code>
In this case we do only one iteration over an array without any hard calculation
within the iterator.</p>

<p>See the benchmark:</p>

<p>```
require 'benchmark'</p>

<p>def n_func(array)
  array.inject({}) { |h, e| h[e] = e; h }
end</p>

<p>def n2_func(array)
  array.inject({}) { |h, e| h.merge(e => e) }
end</p>

<p>BASE_SIZE = 10</p>

<p>4.times do |factor|
  size   = BASE_SIZE * (10 ** factor)
  params = (0..size).to_a
  puts "_" * 60 + "\nSIZE: #{size}"
  Benchmark.bm(10) do |x|</p>

<pre><code>x.report("O(n)" ) { n_func(params)  }
x.report("O(n2)") { n2_func(params) }
</code></pre>

<p>  end
end
```</p>

<p>Output:</p>

<pre><code>____________________________________________________________
SIZE: 10
                user     system      total        real
O(n)        0.000000   0.000000   0.000000 (  0.000014)
O(n2)       0.000000   0.000000   0.000000 (  0.000033)
____________________________________________________________
SIZE: 100
                user     system      total        real
O(n)        0.000000   0.000000   0.000000 (  0.000043)
O(n2)       0.000000   0.000000   0.000000 (  0.001070)
____________________________________________________________
SIZE: 1000
                user     system      total        real
O(n)        0.000000   0.000000   0.000000 (  0.000347)
O(n2)       0.130000   0.000000   0.130000 (  0.127638)
____________________________________________________________
SIZE: 10000
                user     system      total        real
O(n)        0.020000   0.000000   0.020000 (  0.019067)
O(n2)      17.850000   0.080000  17.930000 ( 17.983827)
</code></pre>

<p>It's an obvious and trivial example. Just keep in mind to not do
hard calculation within iterators if it's possible.</p>

<h2>Use bang! methods</h2>

<p>In many cases bang methods do the same as there non-bang analogues but without
duplication an object. The previous example with <code>merge!</code> would be much faster:</p>

<p>```ruby
require 'benchmark'</p>

<p>def merge!(array)
  array.inject({}) { |h, e| h.merge!(e => e) }
end</p>

<p>def merge(array)
  array.inject({}) { |h, e| h.merge(e => e) }
end</p>

<p>N = 10_000
array = (0..N).to_a</p>

<p>Benchmark.bm(10) do |x|
  x.report("merge!") { merge!(array) }
  x.report("merge")  { merge(array)  }
end
```</p>

<p>Output:</p>

<pre><code>                 user     system      total        real
merge!       0.010000   0.000000   0.010000 (  0.011370)
merge       17.710000   0.000000  17.710000 ( 17.840856)
</code></pre>

<h2>Use instance variables</h2>

<p>Accessing instance variable directly is about two times faster than accessing
them with accessor methods:</p>

<p>```ruby
require 'benchmark'</p>

<p>class Metric
  attr_accessor :var</p>

<p>  def initialize(n)</p>

<pre><code>@n   = n
@var = 22
</code></pre>

<p>  end</p>

<p>  def run</p>

<pre><code>Benchmark.bm(10) do |x|
  x.report("@var") { @n.times { @var } }
  x.report("var" ) { @n.times { var  } }
  x.report("@var =")     { @n.times {|i| @var = i     } }
  x.report("self.var =") { @n.times {|i| self.var = i } }
end
</code></pre>

<p>  end
end</p>

<p>metric = Metric.new(100_000_000)
metric.run
```</p>

<p>Output:</p>

<pre><code>                 user     system      total        real
@var         6.980000   0.010000   6.990000 (  7.193725)
var         13.040000   0.000000  13.040000 ( 13.131711)
@var =       7.960000   0.000000   7.960000 (  8.242603)
self.var =  14.910000   0.010000  14.920000 ( 15.960125)
</code></pre>

<h2>Parallel assignment is slower</h2>

<p>```ruby
require 'benchmark'</p>

<p>N = 10_000_000</p>

<p>Benchmark.bm(15) do |x|
  x.report('parallel') do</p>

<pre><code>N.times do
  a, b = 10, 20
end
</code></pre>

<p>  end</p>

<p>  x.report('consequentially') do |x|</p>

<pre><code>N.times do
  a = 10
  b = 20
end
</code></pre>

<p>  end
end
```</p>

<p>Output:</p>

<pre><code>                      user     system      total        real
parallel          1.900000   0.000000   1.900000 (  1.928063)
consequentially   0.880000   0.000000   0.880000 (  0.879675)
</code></pre>

<h2>Dynamic method defention</h2>

<p>What is the faster way to define method dynamically: <code>class_eval</code> with a code string
or using <code>define_method</code>? Which way generated methods work faster?</p>

<p>```ruby
require 'benchmark'</p>

<p>class Metric
  N = 1_000_000</p>

<p>  def self.class_eval_with_string</p>

<pre><code>N.times do |i|
  class_eval(&lt;&lt;-eorb, __FILE__, __LINE__ + 1)
    def smeth_#{i}
      #{i}
    end
  eorb
end
</code></pre>

<p>  end</p>

<p>  def self.with_define_method</p>

<pre><code>N.times do |i|
  define_method("dmeth_#{i}") do
    i
  end
end
</code></pre>

<p>  end
end</p>

<p>Benchmark.bm(22) do |x|
  x.report("class_eval with string") { Metric.class_eval_with_string }
  x.report("define_method")          { Metric.with_define_method     }</p>

<p>  metric = Metric.new
  x.report("string method")  { Metric::N.times { metric.smeth_1 } }
  x.report("dynamic method") { Metric::N.times { metric.dmeth_1 } }
end
```</p>

<p>Output:</p>

<pre><code>                             user     system      total        real
class_eval with string 219.840000   0.720000 220.560000 (221.933074)
define_method           61.280000   0.240000  61.520000 ( 62.070911)
string method            0.110000   0.000000   0.110000 (  0.111433)
dynamic method           0.150000   0.000000   0.150000 (  0.156537)
</code></pre>

<p>So <code>class_eval</code> works slower but it's preferred since methods generated with
<code>class_eval</code> and a string of code work faster.</p>

<h2>Links</h2>

<ul>
<li><a href="http://www.simonecarletti.com/blog/2010/01/how-slow-are-ruby-exceptions/">How Slow Are Ruby Exceptions</a></li>
<li><a href="http://www.igvita.com/2008/07/08/6-optimization-tips-for-ruby-mri/">6 Optimization Tips for Ruby MRI</a>
(NOTE: <code>Symbol#to_proc</code> was ported to Ruby and it's not slow anymore)</li>
<li><a href="http://my.safaribooksonline.com/book/web-development/ruby/9780321540034">"Writing Efficient Ruby Code" by Dr. Stefan Kaes</a></li>
<li><a href="http://programmingzen.com/2007/02/10/top-10-ruby-on-rails-performance-tips/">Top 10 Ruby on Rails performance tips </a></li>
<li><a href="http://blog.monitis.com/index.php/2012/02/08/20-ruby-performance-tips/">20 Ruby Performance Tips</a></li>
<li><a href="http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/">A Beginner’s Guide to Big O Notation</a></li>
</ul>


<p>Danke.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unexpected Ruby behaviour]]></title>
    <link href="http://greyblake.com/blog/2012/08/10/unexpected-ruby-behaviour/"/>
    <updated>2012-08-10T23:28:00+03:00</updated>
    <id>http://greyblake.com/blog/2012/08/10/unexpected-ruby-behaviour</id>
    <content type="html"><![CDATA[<p>Ruby is a cool language with intuitive grammar. However there are a number of things which don't seem to be expected.
It might take long hours to debug some weird issues for unenlightened newbies.</p>

<!--more-->


<h2>Implicitly variable declaration</h2>

<p>Variable mentioned in conditional block of code become declared and initialized with <code>nil</code> even if the declaration was not executed.</p>

<p><code>ruby
if false
  var = "never executed"
end
var # =&gt; nil
</code></p>

<p><strong>Expected:</strong> addressing to <code>var</code> raises <code>NameError: undefined local variable or method 'var'</code></p>

<h2>Calling #utc and #gmt on Time object removes time zone information</h2>

<p>```ruby
t = Time.new  # => Sat Aug 11 01:11:52 +0300 2012
t.utc         # => Fri Aug 10 22:11:52 UTC 2012
t             # => Fri Aug 10 22:11:52 UTC 2012, WTF? O_o</p>

<p>t = Time.new  # => Sat Aug 11 01:17:06 +0300 2012
t.gmtime      # => Fri Aug 10 22:17:06 UTC 2012
t             # => Fri Aug 10 22:17:06 UTC 2012, WTF? O_o
```</p>

<p>IMHO, this methods should be called <code>utc!</code> and <code>gmtime!</code> instead.
I have an experience when it caused a really voodoo thing: a test failed only from 20:00 to 00:00
in USA on CI server, and could never be reproduced in my time zone.</p>

<p>Instead it's better to use <code>getutc</code> and <code>getgm</code> methods which return UTC and GMT time accordingly,
but don't change Time object:</p>

<p>```ruby
t = Time.new  # => Sat Aug 11 01:11:52 +0300 2012
t.getutc      # => Fri Aug 10 22:11:52 UTC 2012
t             # => Sat Aug 11 01:11:52 +0300 2012</p>

<p>t = Time.new  # => Sat Aug 11 01:17:06 +0300 2012
t.getgm       # => Fri Aug 10 22:17:06 UTC 2012
t             # => Sat Aug 11 01:17:06 +0300 2012
```</p>

<h2>Methods do not return value from ensure statement</h2>

<p>Usually ruby methods return the value of the last method line unless <code>return</code> is called explicitly.
But how about this?</p>

<p>```ruby
def run
  1
ensure
  puts "ensure block..."
  2
end</p>

<p>run # => 1</p>

<h1>pints <code>ensure block...</code></h1>

<p>```</p>

<p>So if you want to return a value from <code>ensure</code> statement use <code>return</code> word:</p>

<p>```ruby
def run
  1
ensure
  return 2
end</p>

<p>run # => 2
```</p>

<h2>Anchors ^ and $ do not mean a start and an end of a string</h2>

<p>Most of script languages uses anchors <code>^</code> and <code>$</code> of regular expressions as a start and an end of string accordingly.
But not in Ruby! In Ruby they are a start and an end of a <strong>line</strong>.
See the difference:</p>

<p>```ruby
pattern      = /<sup>[a-zA-Z]{3,12}$/</sup>    # 3-12 alphabetic characters
valid_name   = "Tatiana"
invalid_name = "23\nabc\n!"</p>

<p>valid_name   =~ pattern   # => 0, matchers
invalid_name =~ pattern   # => 3, matchers
```</p>

<p>Instead use <code>\A</code> and <code>\z</code> anchors. They are a start and an end of a <strong>string</strong>.</p>

<p>```ruby
pattern      = /\A[a-zA-Z]{3,12}\z/    # 3-12 alphabetic characters
valid_name   = "Tatiana"
invalid_name = "23\nabc\n!"</p>

<p>valid_name   =~ pattern   # => 0, matchers
invalid_name =~ pattern   # => nil
```</p>

<p>Pay attention when you write validations.
<a href="http://homakov.blogspot.com/2012/05/saferweb-injects-in-various-ruby.html">Read Egor Homakov's article</a>
to get more information about it.</p>

<h2>\m regexp option</h2>

<p>When other languages use <code>\s</code> option to make <code>.</code> match newline, Ruby uses <code>\m</code>:</p>

<p><code>ruby
 "\n" =~ /./   # =&gt; nil
 "\n" =~ /./m  # =&gt; 0
</code></p>

<h2>Calling super and super() are not the same</h2>

<p>There is no matter for ruby methods do you use parentheses or not. But be careful with <code>super</code>
since it's not a method, but a key word.
Let me show an example when parentheses matter:</p>

<p>```ruby
class Parent
  def m1(arg)</p>

<pre><code>puts "Parent m1: arg = #{arg.inspect}"
</code></pre>

<p>  end</p>

<p>  def m2(arg)</p>

<pre><code>puts "Parent m2: arg = #{arg.inspect}"
</code></pre>

<p>  end
end</p>

<p>class Child &lt; Parent
  def m1(arg)</p>

<pre><code>puts "Child m1: arg = #{arg.inspect}"
super
</code></pre>

<p>  end</p>

<p>  def m2(arg)</p>

<pre><code>puts "Child m2: arg = #{arg.inspect}"
super()
</code></pre>

<p>  end
end</p>

<p>child = Child.new
child.m1("foo")
child.m2("bar")
```</p>

<p>Output:</p>

<pre><code>Child m1: arg = "foo"
Parent m1: arg = "foo"
Child m2: arg = "bar"
super.rb:6:in `m2': wrong number of arguments (0 for 1) (ArgumentError)
        from super.rb:19:in `m2'
        from super.rb:25:in `&lt;main&gt;'
</code></pre>

<p>When you use <code>super</code> it calls same method of parent class passing same arguments to it.
But when you use <code>super(...)</code> you have to pass arguments manually. In my example <code>ArgumentError</code>
was raised because <code>Parent#m2</code> expects to receive exactly one argument, but nothing was passed to <code>super()</code></p>

<p>However <code>super()</code> still delegates a passed block. If you don't wanna pass
a block you have to do it explicitly using <code>super(&amp;nil)</code>:</p>

<p>```ruby
class Parent
  def m1</p>

<pre><code>yield
</code></pre>

<p>  end</p>

<p>  def m2</p>

<pre><code>yield
</code></pre>

<p>  end
end</p>

<p>class Child &lt; Parent
  def m1</p>

<pre><code>super()
</code></pre>

<p>  end</p>

<p>  def m2</p>

<pre><code>super(&amp;nil)
</code></pre>

<p>  end
end</p>

<p>child = Child.new
child.m1 { puts "Hi, m1" }
child.m2 { puts "Hi, m2" }
```</p>

<p>Output:</p>

<pre><code>Hi, m1
/tmp/super.rb:7:in `m2': no block given (yield) (LocalJumpError)
</code></pre>

<h2>lambda and Proc.new act differently</h2>

<p>It's a well known thing but I want to remind.
There 2 differences between proc objects created with <code>lambda</code> and <code>Proc.new</code>:</p>

<ul>
<li><code>lambda</code> raises <code>ArgumentError</code> if parameter is missing when <code>Proc.new</code> uses <code>nil</code> instead.</li>
</ul>


<p>```ruby
lm = lambda   {|a, b| "#{a.inspect} and #{b.inspect}" }
pr = Proc.new {|a, b| "#{a.inspect} and #{b.inspect}" }</p>

<p>lm.call(10)  # => ArgumentError: wrong number of arguments (1 for 2)
pr.call(10)  # => "10 and nil"
```</p>

<ul>
<li>For <code>lambda</code> word <code>return</code> means returning from proc object, when for <code>Proc.new</code> it means returning from scope where proc is defined.</li>
</ul>


<p>```ruby
def lambda_method
  lm = lambda { return 10 }     # return from lambda
  half = lm.call
  half * 2
end</p>

<p>def proc_method
  pr = Proc.new { return 10 }   # return from proc_method
  half = pr.call
  half * 2
end</p>

<p>lambda_method   # => 20
proc_method     # => 10
```</p>

<p>Note there is also method <code>proc</code>. In Ruby 1.8 it's a synonym for <code>lambda</code>
but in Ruby 1.9 it's a synonym for <code>Proc.new</code>. So avoid using <code>proc</code> to keep you code compatible
for both ruby versions.</p>

<h2>DelegateClass instance does not eql itself</h2>

<p>Ruby standard library provides <a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/delegate/rdoc/Object.html">DelegateClass</a>
which can be <a href="http://pivotallabs.com/users/jdean/blog/articles/1138-delegateclass-rocks-my-world">pretty useful</a>.
But some things are not so obvious about it:</p>

<p>```ruby
require 'delegate'</p>

<p>class Animal
end</p>

<p>class Dog &lt; DelegateClass(Animal)
end</p>

<p>animal = Animal.new
dog = Dog.new(animal)</p>

<p>dog.eql?(dog)  # => false, WTF? O_o
```</p>

<p>It happens because <code>eql?</code> is delegated to base object(animal):</p>

<p><code>ruby
dog.eql?(animal)  # =&gt; true
</code></p>

<p>On other hand <code>equal?</code> is not:</p>

<p><code>ruby
dog.equal?(dog)     # =&gt; true
dog.equal?(animal)  # =&gt; false
</code></p>

<h2>dup method do not work for all objects</h2>

<p>As you might know every object in Ruby has <a href="http://ruby-doc.org/core-1.9.3/Object.html#method-i-dup">dup</a>
method inherited from <code>Object</code> class. It's convenient, I like it. But <strong>it does not mean that every object
can be duplicated</strong>.</p>

<p><code>ruby
[:symbol, true, false].all? { |obj| obj.respond_to? :dup } # =&gt; true
:symbol.dup   # =&gt; TypeError: can't dup Symbol
true.dup      # =&gt; TypeError: can't dup TrueClass
false.dup     # =&gt; TypeError: can't dup FalseClass
</code></p>

<p>It means you can't make a deep copy of an array (with one level depth) like this:</p>

<p><code>ruby
copy = array.map(&amp;:dup)
</code></p>

<p>Or like this:</p>

<p><code>
copy = array.map { |val| val.respond_to?(:dup) ? val.dup : val }
</code></p>

<p>Since all your objects respond to <code>#dup</code>.</p>

<p>ActiveSupport provides <code>duplicable?</code> method to inspect an ability
to duplicate an object, so finally your solution would look the next way:</p>

<p><code>ruby
copy = array.map { |val| val.duplicable? ? val.dup : val }
</code></p>

<p>Internally ruby symbols and booleans point to constant memory addresses, and
there is no reason to copy them since they are unchangable.
But I wish the implementation of their <code>#dup</code> methods looked like this:</p>

<p>```ruby
class Symbol
  def dup</p>

<pre><code>self
</code></pre>

<p>  end
end
```</p>

<br />


<br />


<p>So I hope the article was useful for you.
If you know some fancy Ruby things I haven't mentioned please let me know.</p>

<p>Thanks.</p>
]]></content>
  </entry>
  
</feed>
