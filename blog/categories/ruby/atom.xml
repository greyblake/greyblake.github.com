<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Sergey Potapov]]></title>
  <link href="http://greyblake.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://greyblake.com/"/>
  <updated>2013-08-20T19:59:43+03:00</updated>
  <id>http://greyblake.com/</id>
  <author>
    <name><![CDATA[Sergey Potapov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Validation in rails with Themis]]></title>
    <link href="http://greyblake.com/blog/2013/08/19/validation-in-rails-with-themis/"/>
    <updated>2013-08-19T17:21:00+03:00</updated>
    <id>http://greyblake.com/blog/2013/08/19/validation-in-rails-with-themis</id>
    <content type="html"><![CDATA[<p>Sometimes ActiveRecord is not enough to meet complicated validation needs.
At <a href="http://tmxcredit.com/">TMXCredit</a> we've created <a href="https://github.com/TMXCredit/themis">Themis</a> -
ActiveRecord extension which helps to organize validations in a better way and adds
some flexibility. Here I'm gonna describe some problems which Themis solves after that
I'll take a brief look at possible alternative solutions.</p>

<h2>Modular validation</h2>

<p>Themis allows you to extract duplicated validation into model.
Usually rails applications are small enough so you don't need it. But sometimes
you do.</p>

<p>The next example is pretty flat(in real life you probably would use STI or composition to
represent <code>Doctor</code> and <code>Patient</code> models) but it illustrates where Themis could be useful.</p>

<p>Let's say you have 2 models:</p>

<p>```ruby
class Doctor &lt; ActiveRecord::Base
  validates :first_name, :last_name, :email, :diploma,</p>

<pre><code>        :presence =&gt; true
</code></pre>

<p>end</p>

<p>class Patient &lt; ActiveRecord::Base
  validates :first_name, :last_name, :email, :age,</p>

<pre><code>        :presence =&gt; true
</code></pre>

<p>end
```</p>

<p>You see that both models have same validation of <code>first_name</code>, <code>last_name</code> and <code>email</code>.</p>

<p>Themis allows to fix the duplication problem by extracting common validations into
a module:</p>

<p>```ruby</p>

<h1>Module with common validations.</h1>

<p>module PersonValidation
  extend Themis::Validation</p>

<p>  validates :first_name, :last_name, :email, :presence => true
end</p>

<p>class Doctor &lt; ActiveRecord::Base
  # import validation of first_name, last_name, email
  include PersonValidation</p>

<p>  validates :diploma, :presence => true
end</p>

<p>class Patient &lt; ActiveRecord::Base
  include PersonValidation</p>

<p>  validates :age, :presence => true
end
```</p>

<!--more-->


<p>So now we keep common validation in one place.
If you want you can include validation modules into each other to combine
necessary validation.</p>

<h2>Validation scenarios</h2>

<p>Here is another problem which Themis solves.</p>

<p>We have the following models:</p>

<p>```ruby
class User &lt; ActiveRecord::Base
  has_one :person
  has_many :user_accounts
end</p>

<p>class Person &lt; ActiveRecord::Base
  attr_accessible :first_name, :last_name, :birhday</p>

<p>  belongs_to :user
end</p>

<p>class UserAccount &lt; ActiveRecord::Base
  attr_accessible :email, :login</p>

<p>  belongs_to :user
end
```</p>

<p>So we have model graph like this with <code>User</code> model on the top:</p>

<p><img src="http://i1078.photobucket.com/albums/w484/greyblake/themis_model_graph.png" alt="Themis - model graph" /></p>

<p>it's pretty small, but in real life the graph can be much deeper.</p>

<p>What would you do if you needed to apply different validations depending on context?
For example according to your business requirements users must be allowed to use
your application only in case if they filled in all of the fields.
So you need to validate presense of <code>first_name</code>, <code>last_name</code> and <code>birhday</code>
on <code>Person</code> model and <code>email</code>, <code>login</code> and <code>password</code> on <code>UserAccount</code>.</p>

<p>It's not a problem, just add the validations to appropriate models:</p>

<p>```ruby
class Person &lt; ActiveRecord::Base
  validates :first_name, :layout, :birhday, :presence => true
end</p>

<p>class UserAccount &lt; ActiveRecord::Base
  validates :email, :login, :presence => true
end
```</p>

<p>There are some percent of users who don't finish registration process.
But your marketing department wants to have an ability to contact them
in case if they have entered an email address.</p>

<p>So that's where the issue is: you can't save records using validation rules written above.</p>

<p>With Themis can declare number of validation strategies
and depending on context chose which one you need.</p>

<p>Here is how complete solution looks:</p>

<p>```ruby
class User &lt; ActiveRecord::Base
  has_one :person
  has_many :user_accounts</p>

<p>  accepts_nested_attributes_for :person, :user_accounts</p>

<p>  # Declare validations. Use :full as default.
  has_validation :full, :default => true
  has_validation :partial
end</p>

<p>class Person &lt; ActiveRecord::Base
  attr_accessible :first_name, :last_name, :birhday</p>

<p>  belongs_to :user</p>

<p>  # Declare full validation
  has_validation :full do |model|</p>

<pre><code>model.validates :first_name, :last_name, :birhday, :presence =&gt; true
</code></pre>

<p>  end</p>

<p>  # Delcare partial validation. Nothing to validate.
  has_validation :partial
end</p>

<p>class UserAccount &lt; ActiveRecord::Base
  attr_accessible :email, :login</p>

<p>  has_validation :full do |model|</p>

<pre><code>model.validates :login, :email, :presence =&gt; true
</code></pre>

<p>  end</p>

<p>  has_validation :partial do |model|</p>

<pre><code>model.validates :email, :presence =&gt; true
</code></pre>

<p>  end
end
```</p>

<p>And here how you would use it somewhere in controller:</p>

<p>```ruby</p>

<h1>Create model initialized with params</h1>

<p>user = User.new(
  :person => {</p>

<pre><code>:first_name =&gt; "Alex",
:last_name  =&gt; "DeLarge",
:birhday    =&gt; "1962"
</code></pre>

<p>  },
  :user_accounts => [{</p>

<pre><code>:email =&gt; "clockwork@orange.com"
</code></pre>

<p>  }]
)</p>

<p>user.valid? # => false, because login is missing</p>

<h1>Try to apply partial validation</h1>

<p>user.use_validation(:partial)
user.valid? # => true</p>

<h1>We can save it</h1>

<p>user.save!
```</p>

<h2>Alternative solutions</h2>

<p>If you think Themis is overkill for your project, you still have some options.</p>

<h3>Using ActiveSupport::Concern for modularity</h3>

<p><code>ActiveSupport::Concern</code> is another way which allows to extract common validations
into module. Here how would <code>PersonValidation</code> module described above could look:</p>

<p>```ruby
module PersonValidation
  extend ActiveSupport::Concern</p>

<p>  included do</p>

<pre><code>validates :first_name, :last_name, :email, :presence =&gt; true
</code></pre>

<p>  end
end</p>

<p>```</p>

<h3>Using conditional validation</h3>

<p>If your requirements aren't so fancy you can be satisfied with simple
conditional validation, e. g.</p>

<p>```ruby
class Person &lt; ActiveRecord::Base
  validates :first_name, :last_name, :birhday, :presence => true,</p>

<pre><code>        :if =&gt; :use_full_validation?
</code></pre>

<p>  # Lets add one more validation statement(for the next example)
  validates :first_name, :last_name, :length => { :maximum => 255 },</p>

<pre><code>        :if =&gt; :use_full_validation?
</code></pre>

<p>  def use_full_validation?</p>

<pre><code># Some logic goes here
</code></pre>

<p>  end
end
```</p>

<p>To DRY up <code>:if</code> options it's good to use <code>with_options</code> method:</p>

<p>```ruby
class Person &lt; ActiveRecord::Base
  with_options :if => :use_full_validation? do |person|</p>

<pre><code>person.validates :first_name, :last_name, :birhday, :presence =&gt; true
person.validates :first_name, :last_name, :length =&gt; { :maximum =&gt; 255 }
</code></pre>

<p>  end
end
```</p>

<p>Now <code>:if =&gt; :use_full_validation</code> will be additonaly passed to every method call
on <code>person</code> inside the block.</p>

<h3>Vanguard</h3>

<p>Guys from <a href="http://rom-rb.org/">ROM project</a> have own validator called
<a href="https://github.com/mbj/vanguard">Vanguard</a>(previous name is Aqeuitas).
The sweet thing about it is that it allows to seperate validations and
models according to DataMapper approach. The downside is if you use ActiveRecord
you'll have a zoo of validation tools. Also it may be still raw and I'm not sure
is it possible to apply it to solve the described problem, but I'd encourage
you to take a look at it.</p>

<h2>Conclusion</h2>

<p>ActiveRecord is good for plain and straightforward projects.
In big enterprise applications usually we need more flexebility to meet different
exotic requiments.
We've created <a href="https://github.com/TMXCredit/themis">Themis</a> to extend ActiveRecord
and solve some of the problems.
Actually I hope that <a href="http://rom-rb.org/">ROM</a> will be ready soon and we'll
have an ability to select right ORM before diving into development.</p>

<p>Thanks for reading. Hope the article was useful for you and I'm wating for
your feedback!</p>

<h2>Links</h2>

<ul>
<li><a href="https://github.com/TMXCredit/themis">Themis on Github</a> - you'll find here comprehensive documentation in README;</li>
<li><a href="http://guides.rubyonrails.org/active_record_validations.html#conditional-validation">Conditional validation</a> - extraction from Rails Guide;</li>
<li><a href="https://github.com/mbj/vanguard">Vanguard on Github</a> - validator for ROM project;</li>
<li><a href="http://railscasts.com/episodes/42-with-options">Railscast: #42</a> - Ryan Bates describes how <code>with_options</code> works.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rational can't be coerced into BigDecimal in ruby 1.9.3]]></title>
    <link href="http://greyblake.com/blog/2012/12/20/rational-cant-be-coerced-into-bigdecimal-in-ruby-1-dot-9-3/"/>
    <updated>2012-12-20T16:34:00+02:00</updated>
    <id>http://greyblake.com/blog/2012/12/20/rational-cant-be-coerced-into-bigdecimal-in-ruby-1-dot-9-3</id>
    <content type="html"><![CDATA[<p>Trying to move a rails application from ruby 1.8.7 to 1.9.3 I ran into coercion
issue of <code>Rational</code> class.</p>

<p>Ruby 1.9.3:
```ruby
require 'bigdecimal'
require 'rational'</p>

<h1>You can multiply Rational against BigDecimal</h1>

<p>Rational(1) * BigDecimal('1')  # => &lt;BigDecimal:a566d0,'0.1E1',9(36)></p>

<h1>But you can't do the same when you change order</h1>

<p>BigDecimal('1') * Rational(1)  # => TypeError: Rational can't be coerced into BigDecimal
```</p>

<p>On other hand in Ruby 1.8.7:</p>

<p>```ruby
require 'bigdecimal'
require 'rational'</p>

<h1>BigDecimal * Rational works OK</h1>

<p>BigDecimal('1') * Rational(1)  # => 1.0 (Float)</p>

<h1>But Rational * BigDecimal doesn't</h1>

<p>Rational(1) * BigDecimal('1')  # => TypeError: Rational can't be coerced into BigDecimal
```</p>

<p>It's looks weird. So I can only say for sure that <code>Rational</code> -> <code>BigDecimal</code>
coercion is not implemented in Ruby.</p>

<p>I've tried to fix it with simple monkey patch:</p>

<p>```ruby</p>

<h1>Works only for Ruby1.9.3</h1>

<p>class Rational
  def coerce(value)</p>

<pre><code>case value
when BigDecimal
  return self, value
else
  super
end
</code></pre>

<p>  end
end
```</p>

<p>And it works OK against simple examples:</p>

<p><code>ruby
Rational(1) * BigDecimal('1')  # =&gt; &lt;BigDecimal:a566d0,'0.1E1',9(36)&gt;
BigDecimal('1') * Rational(1)  # =&gt; &lt;BigDecimal:a566d0,'0.1E1',9(36)&gt;
</code></p>

<p>But it causes intermittent segmentation faults when I run Rails application.</p>

<p>Any ideas about the coercion? Is it expected behaviour of ruby1.9.3?
I found no bugs reported this issue on
<a href="bugs.ruby-lang.org">https://bugs.ruby-lang.org</a>.</p>

<p>I'll appreciate any feedback. Thanks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Custom expectations with RSpec]]></title>
    <link href="http://greyblake.com/blog/2012/12/14/custom-expectations-with-rspec/"/>
    <updated>2012-12-14T00:34:00+02:00</updated>
    <id>http://greyblake.com/blog/2012/12/14/custom-expectations-with-rspec</id>
    <content type="html"><![CDATA[<p>I know you love RSpec's <code>expect</code> DSL like this:</p>

<p><code>ruby
expect { raise("Boom!") }.to raise_error(RuntimeError, "Boom!")
</code></p>

<p>We often write our own custom matchers and I wanna show how is easy to write
custom expectation.</p>

<h2>Desired DSL</h2>

<p>Usually when I do things like this I start with DSL. I think it's important since
it must be convenient to use and easy to read.
So turn on your imagination and spend some time on it.</p>

<p>In my example I'm gonna create an expectation to test text written to standard output
and standard error.
There are samples how I wanna use it(desired DSL):</p>

<p>```ruby</p>

<h1>Test text written to standard output</h1>

<p>expect { puts "Hello!" }.to write("Hello!")</p>

<h1>Test text written to standard error</h1>

<p>expect { warn "Stop it!" }.to write("Stop it!").to(:error)
```</p>

<!--more-->


<h2>Expectation</h2>

<p>I bet you've already created number of custom matchers. What about custom expectations?
They are usual custom matches which test blocks of code!</p>

<p>I'm gonna locate the expectation in <code>spec/support/custom_expectations/write_expectation.rb</code> file.
I think <code>spec/support/custom_expectations/</code> directory is the right place for it since
custom matchers usually are located in <code>spec/support/custom_matchers/</code>.</p>

<p>So finally the expectation looks this way:</p>

<p>```ruby spec/support/custom_expectations/write_expectation.rb
RSpec::Matchers.define :write do |message|
  chain(:to) do |io|</p>

<pre><code>@io = io
</code></pre>

<p>  end</p>

<p>  match do |block|</p>

<pre><code>output =
  case io
  when :output then fake_stdout(&amp;block)
  when :error  then fake_stderr(&amp;block)
  else raise("Allowed values for `to` are :output and :error, got `#{io.inspect}`")
  end
output.include? message
</code></pre>

<p>  end</p>

<p>  description do</p>

<pre><code>"write \"#{message}\" #{io_name}"
</code></pre>

<p>  end</p>

<p>  failure_message_for_should do</p>

<pre><code>"expected to #{description}"
</code></pre>

<p>  end</p>

<p>  failure_message_for_should_not do</p>

<pre><code>"expected to not #{description}"
</code></pre>

<p>  end</p>

<p>  # Fake STDERR and return a string written to it.
  def fake_stderr</p>

<pre><code>original_stderr = $stderr
$stderr = StringIO.new
yield
$stderr.string
</code></pre>

<p>  ensure</p>

<pre><code>$stderr = original_stderr
</code></pre>

<p>  end</p>

<p>  # Fake STDOUT and return a string written to it.
  def fake_stdout</p>

<pre><code>original_stdout = $stdout
$stdout = StringIO.new
yield
$stdout.string
</code></pre>

<p>  ensure</p>

<pre><code>$stdout = original_stdout
</code></pre>

<p>  end</p>

<p>  # default IO is standard output
  def io</p>

<pre><code>@io ||= :output
</code></pre>

<p>  end</p>

<p>  # IO name is used for description message
  def io_name</p>

<pre><code>{:output =&gt; "standard output", :error =&gt; "standard error"}[io]
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>And that's it. You can try it against the examples from "Desired DSL" section.</p>

<p>Hope that's was useful. I look forward for your comments and suggestions. You know I do! =)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pg_power - ActiveRecord extension for PostgreSQL]]></title>
    <link href="http://greyblake.com/blog/2012/09/06/pg-power-activerecord-extension-for-postgresql/"/>
    <updated>2012-09-06T23:24:00+03:00</updated>
    <id>http://greyblake.com/blog/2012/09/06/pg-power-activerecord-extension-for-postgresql</id>
    <content type="html"><![CDATA[<p>I am happy to announce that  <a href="http://tmxcredit.com/">TMXCredit</a> released
<a href="https://github.com/TMXCredit/pg_power">pg_power</a> gem - an ActiveRecord extension which
allows to use number of PostgreSQL features with Rails.</p>

<h2>What you can do with pg_power?</h2>

<ul>
<li>Use PostgresSQL schemas in your Rails project.</li>
<li>Add comments to PostgreSQL database with Rails migrations.</li>
<li>Use foreign keys (we imported foreigner functionality and made it schema aware).</li>
<li>Use partial indexes.</li>
<li>Add indexes concurrently.</li>
</ul>


<p>You'll find enough documentation in <a href="https://github.com/TMXCredit/pg_power/blob/master/README.markdown">README</a>
file.</p>

<h2>Quick usage example</h2>

<p>Assume you want to create tables <code>countries</code> and <code>languages</code> in <code>demography</code> schema.</p>

<p>At first we need to create <code>demography</code> schema:</p>

<p>```ruby db/migrate/create_demography_schema.rb
class CreateDemographySchema &lt; &lt; ActiveRecord::Migration
  def change</p>

<pre><code>create_schema 'demography'
</code></pre>

<p>  end
end
```</p>

<p>Now let's create tables:</p>

<p>```ruby db/migrate/create_demography_languages.rb
class CreateDemographyLanguages &lt; ActiveRecord::Migration
  def change</p>

<pre><code># Create table `languages` in schema `demography`
create_table "languages", :schema =&gt; "demography" do |t|
  t.string :name
  t.string :code, :limit =&gt; 2
end

# Add PostgreSQL comments
set_table_comment "demography.languages", "List of languages"
set_column_comments "demography.languages",
    :name =&gt; "Full name of language in English",
    :code =&gt; "ISO 639-1 code"
</code></pre>

<p>  end
end
```</p>

<p>```ruby db/migrate/create_demography_countries.rb
class CreateDemographyContries &lt; ActiveRecord::Migration
  def change</p>

<pre><code># Create table `countries` in schema `demography`
create_table "countries", :schema =&gt; "demography" do |t|
  t.string :name

  # In real life you likely would have many-to-many associaton
  t.integer :language_id
end

# Add PostgreSQL comments
set_table_comment "demography.countries", "List of world countries"
set_column_comments "demography.languages",
    :name        =&gt; "Full name of country in English",
    :language_id =&gt; "Most popular language in the country"

# Add foreign key and create index on demography.countries.language_id
add_foreign_key("demography.countries", "demography.languages")
</code></pre>

<p>  end
end
```</p>

<p>Great! Now we need to set table names in models to make ActiveRecord know that
these tables are located in <code>demography</code> schema.</p>

<p><code>ruby app/models/language.rb
class Language &lt; ActiveRecord::Base
  set_table_name "demography.languages"
end
</code></p>

<p>It will work. But I would recommend you to create module <code>Demography</code> which would represent
<code>demography</code> schema and move those models to it. One more benefit is that you can define
schema prefix in module and models will use it build table name automatically.</p>

<p>```ruby app/models/demography.rb
module Demography
  def self.table_name_prefix</p>

<pre><code>'demography.'
</code></pre>

<p>  end
end
```</p>

<p><code>ruby app/models/demography/language.rb
module Demography::Language
  # No need to use set_table_name anymore
end
</code></p>

<p>I hope you will enjoy <a href="https://github.com/TMXCredit/pg_power">pg_power</a>. Let us know what you think!</p>

<p>Thanks. Sergey Potapov.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby performance tricks]]></title>
    <link href="http://greyblake.com/blog/2012/09/02/ruby-perfomance-tricks/"/>
    <updated>2012-09-02T23:34:00+03:00</updated>
    <id>http://greyblake.com/blog/2012/09/02/ruby-perfomance-tricks</id>
    <content type="html"><![CDATA[<p>I did some benchmarks to find out which alternatives to write code work faster. I wanna
share it with you. All benchmarks are made against ruby 1.9.3p194 MRI.</p>

<h2>Do not use exceptions for a control flow</h2>

<p>The next example is pretty stupid but it shows how exceptions slow against
conditional statements.</p>

<p>```ruby
require 'benchmark'</p>

<p>class Obj
  def with_condition</p>

<pre><code>respond_to?(:mythical_method) ? self.mythical_method : nil
</code></pre>

<p>  end</p>

<p>  def with_rescue</p>

<pre><code>self.mythical_method
</code></pre>

<p>  rescue NoMethodError</p>

<pre><code>nil
</code></pre>

<p>  end
end</p>

<p>obj = Obj.new
N = 10_000_000</p>

<p>puts RUBY_DESCRIPTION</p>

<p>Benchmark.bm(15, "rescue/condition") do |x|
  rescue_report     = x.report("rescue:")    { N.times { obj.with_rescue  } }
  condition_report  = x.report("condition:") { N.times { obj.with_if      } }
  [rescue_report / condition_report]
end
```</p>

<p>MRI 1.9.3:</p>

<pre><code>ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-linux]
                        user     system      total        real
rescue:           111.530000   2.650000 114.180000 (115.837103)
condition:          2.620000   0.010000   2.630000 (  2.633154)
rescue/condition:  42.568702 265.000000        NaN ( 43.991767)
</code></pre>

<p>MRI 1.8.7 (REE has similar result):</p>

<pre><code>ruby 1.8.7 (2011-12-28 patchlevel 357) [x86_64-linux]
                        user     system      total        real
rescue:            80.510000   0.940000  81.450000 ( 81.529022)
if:                 3.320000   0.000000   3.320000 (  3.330166)
rescue/condition:  24.250000        inf       -nan ( 24.481970)
</code></pre>

<!--more-->


<h2>String concatenation</h2>

<p>Avoid using <code>+=</code> to concatenate strings in favor of <code>&lt;&lt;</code> method.
The result is absolutely the same: add a string to the end of an existing one.
What is the difference then?</p>

<p>See the example:</p>

<p>```ruby
str1 = "first"
str2 = "second"
str1.object_id       # => 16241320</p>

<p>str1 += str2    # str1 = str1 + str2
str1.object_id  # => 16241240, id is changed</p>

<p>str1 &lt;&lt; str2
str1.object_id  # => 16241240, id is the same
```</p>

<p>When you use <code>+=</code> ruby creates a temporal object which is result of <code>str1 + str2</code>.
Then it overrides <code>str1</code> variable with reference to the new built object.
On other hand <code>&lt;&lt;</code> modifies existing one.</p>

<p>As a result of using <code>+=</code> you have the next disadvantages:</p>

<ul>
<li>More calculation to join strings.</li>
<li>Redundant string object in memory (previous value of <code>str1</code>), which approximates time when
<a href="http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29">GC</a> will trigger.</li>
</ul>


<p>How <code>+=</code> is slow? Basically it depends on length of strings you have operation with.</p>

<p>```ruby
require 'benchmark'</p>

<p>N = 1000
BASIC_LENGTH = 10</p>

<p>5.times do |factor|
  length = BASIC_LENGTH * (10 ** factor)
  puts "_" * 60 + "\nLENGTH: #{length}"</p>

<p>  Benchmark.bm(10, '+= VS &lt;&lt;') do |x|</p>

<pre><code>concat_report = x.report("+=")  do
  str1 = ""
  str2 = "s" * length
  N.times { str1 += str2 }
end

modify_report = x.report("&lt;&lt;")  do
  str1 = "s"
  str2 = "s" * length
  N.times { str1 &lt;&lt; str2 }
end

[concat_report / modify_report]
</code></pre>

<p>  end
end
```</p>

<p>Output:</p>

<pre><code>____________________________________________________________
LENGTH: 10
                 user     system      total        real
+=           0.000000   0.000000   0.000000 (  0.004671)
&lt;&lt;           0.000000   0.000000   0.000000 (  0.000176)
+= VS &lt;&lt;          NaN        NaN        NaN ( 26.508796)
____________________________________________________________
LENGTH: 100
                 user     system      total        real
+=           0.020000   0.000000   0.020000 (  0.022995)
&lt;&lt;           0.000000   0.000000   0.000000 (  0.000226)
+= VS &lt;&lt;          Inf        NaN        NaN (101.845829)
____________________________________________________________
LENGTH: 1000
                 user     system      total        real
+=           0.270000   0.120000   0.390000 (  0.390888)
&lt;&lt;           0.000000   0.000000   0.000000 (  0.001730)
+= VS &lt;&lt;          Inf        Inf        NaN (225.920077)
____________________________________________________________
LENGTH: 10000
                 user     system      total        real
+=           3.660000   1.570000   5.230000 (  5.233861)
&lt;&lt;           0.000000   0.010000   0.010000 (  0.015099)
+= VS &lt;&lt;          Inf 157.000000        NaN (346.629692)
____________________________________________________________
LENGTH: 100000
                 user     system      total        real
+=          31.270000  16.990000  48.260000 ( 48.328511)
&lt;&lt;           0.050000   0.050000   0.100000 (  0.105993)
+= VS &lt;&lt;   625.400000 339.800000        NaN (455.961373)
</code></pre>

<h2>Be careful with calculation within iterators</h2>

<p>Assume you need to write a function to convert an array into a hash
where keys and values are same as elements of the array:</p>

<p><code>ruby
func([1, 2, 3])  # =&gt; {1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3}
</code></p>

<p>The next solution would satisfy the requirements:</p>

<p><code>ruby
def func(array)
  array.inject({}) { |h, e| h.merge(e =&gt; e) }
end
</code>
And would be extremely slow with big portions of data because it contains
nested methods (<code>inject</code> and <code>merge</code>), so it's <strong> O(n<sup>2</sup>) </strong> algorithm.
But it's obviously that it must be <strong> O(n) </strong>.
Consider the next:</p>

<p><code>ruby
def func(array)
  array.inject({}) { |h, e| h[e] = e; h }
end
</code>
In this case we do only one iteration over an array without any hard calculation
within the iterator.</p>

<p>See the benchmark:</p>

<p>```
require 'benchmark'</p>

<p>def n_func(array)
  array.inject({}) { |h, e| h[e] = e; h }
end</p>

<p>def n2_func(array)
  array.inject({}) { |h, e| h.merge(e => e) }
end</p>

<p>BASE_SIZE = 10</p>

<p>4.times do |factor|
  size   = BASE_SIZE * (10 ** factor)
  params = (0..size).to_a
  puts "_" * 60 + "\nSIZE: #{size}"
  Benchmark.bm(10) do |x|</p>

<pre><code>x.report("O(n)" ) { n_func(params)  }
x.report("O(n2)") { n2_func(params) }
</code></pre>

<p>  end
end
```</p>

<p>Output:</p>

<pre><code>____________________________________________________________
SIZE: 10
                user     system      total        real
O(n)        0.000000   0.000000   0.000000 (  0.000014)
O(n2)       0.000000   0.000000   0.000000 (  0.000033)
____________________________________________________________
SIZE: 100
                user     system      total        real
O(n)        0.000000   0.000000   0.000000 (  0.000043)
O(n2)       0.000000   0.000000   0.000000 (  0.001070)
____________________________________________________________
SIZE: 1000
                user     system      total        real
O(n)        0.000000   0.000000   0.000000 (  0.000347)
O(n2)       0.130000   0.000000   0.130000 (  0.127638)
____________________________________________________________
SIZE: 10000
                user     system      total        real
O(n)        0.020000   0.000000   0.020000 (  0.019067)
O(n2)      17.850000   0.080000  17.930000 ( 17.983827)
</code></pre>

<p>It's an obvious and trivial example. Just keep in mind to not do
hard calculation within iterators if it's possible.</p>

<h2>Use bang! methods</h2>

<p>In many cases bang methods do the same as there non-bang analogues but without
duplication an object. The previous example with <code>merge!</code> would be much faster:</p>

<p>```ruby
require 'benchmark'</p>

<p>def merge!(array)
  array.inject({}) { |h, e| h.merge!(e => e) }
end</p>

<p>def merge(array)
  array.inject({}) { |h, e| h.merge(e => e) }
end</p>

<p>N = 10_000
array = (0..N).to_a</p>

<p>Benchmark.bm(10) do |x|
  x.report("merge!") { merge!(array) }
  x.report("merge")  { merge(array)  }
end
```</p>

<p>Output:</p>

<pre><code>                 user     system      total        real
merge!       0.010000   0.000000   0.010000 (  0.011370)
merge       17.710000   0.000000  17.710000 ( 17.840856)
</code></pre>

<h2>Use instance variables</h2>

<p>Accessing instance variable directly is about two times faster than accessing
them with accessor methods:</p>

<p>```ruby
require 'benchmark'</p>

<p>class Metric
  attr_accessor :var</p>

<p>  def initialize(n)</p>

<pre><code>@n   = n
@var = 22
</code></pre>

<p>  end</p>

<p>  def run</p>

<pre><code>Benchmark.bm(10) do |x|
  x.report("@var") { @n.times { @var } }
  x.report("var" ) { @n.times { var  } }
  x.report("@var =")     { @n.times {|i| @var = i     } }
  x.report("self.var =") { @n.times {|i| self.var = i } }
end
</code></pre>

<p>  end
end</p>

<p>metric = Metric.new(100_000_000)
metric.run
```</p>

<p>Output:</p>

<pre><code>                 user     system      total        real
@var         6.980000   0.010000   6.990000 (  7.193725)
var         13.040000   0.000000  13.040000 ( 13.131711)
@var =       7.960000   0.000000   7.960000 (  8.242603)
self.var =  14.910000   0.010000  14.920000 ( 15.960125)
</code></pre>

<h2>Parallel assignment is slower</h2>

<p>```ruby
require 'benchmark'</p>

<p>N = 10_000_000</p>

<p>Benchmark.bm(15) do |x|
  x.report('parallel') do</p>

<pre><code>N.times do
  a, b = 10, 20
end
</code></pre>

<p>  end</p>

<p>  x.report('consequentially') do |x|</p>

<pre><code>N.times do
  a = 10
  b = 20
end
</code></pre>

<p>  end
end
```</p>

<p>Output:</p>

<pre><code>                      user     system      total        real
parallel          1.900000   0.000000   1.900000 (  1.928063)
consequentially   0.880000   0.000000   0.880000 (  0.879675)
</code></pre>

<h2>Dynamic method defention</h2>

<p>What is the faster way to define method dynamically: <code>class_eval</code> with a code string
or using <code>define_method</code>? Which way generated methods work faster?</p>

<p>```ruby
require 'benchmark'</p>

<p>class Metric
  N = 1_000_000</p>

<p>  def self.class_eval_with_string</p>

<pre><code>N.times do |i|
  class_eval(&lt;&lt;-eorb, __FILE__, __LINE__ + 1)
    def smeth_#{i}
      #{i}
    end
  eorb
end
</code></pre>

<p>  end</p>

<p>  def self.with_define_method</p>

<pre><code>N.times do |i|
  define_method("dmeth_#{i}") do
    i
  end
end
</code></pre>

<p>  end
end</p>

<p>Benchmark.bm(22) do |x|
  x.report("class_eval with string") { Metric.class_eval_with_string }
  x.report("define_method")          { Metric.with_define_method     }</p>

<p>  metric = Metric.new
  x.report("string method")  { Metric::N.times { metric.smeth_1 } }
  x.report("dynamic method") { Metric::N.times { metric.dmeth_1 } }
end
```</p>

<p>Output:</p>

<pre><code>                             user     system      total        real
class_eval with string 219.840000   0.720000 220.560000 (221.933074)
define_method           61.280000   0.240000  61.520000 ( 62.070911)
string method            0.110000   0.000000   0.110000 (  0.111433)
dynamic method           0.150000   0.000000   0.150000 (  0.156537)
</code></pre>

<p>So <code>class_eval</code> works slower but it's preferred since methods generated with
<code>class_eval</code> and a string of code work faster.</p>

<h2>Links</h2>

<ul>
<li><a href="http://www.simonecarletti.com/blog/2010/01/how-slow-are-ruby-exceptions/">How Slow Are Ruby Exceptions</a></li>
<li><a href="http://www.igvita.com/2008/07/08/6-optimization-tips-for-ruby-mri/">6 Optimization Tips for Ruby MRI</a>
(NOTE: <code>Symbol#to_proc</code> was ported to Ruby and it's not slow anymore)</li>
<li><a href="http://my.safaribooksonline.com/book/web-development/ruby/9780321540034">"Writing Efficient Ruby Code" by Dr. Stefan Kaes</a></li>
<li><a href="http://programmingzen.com/2007/02/10/top-10-ruby-on-rails-performance-tips/">Top 10 Ruby on Rails performance tips </a></li>
<li><a href="http://blog.monitis.com/index.php/2012/02/08/20-ruby-performance-tips/">20 Ruby Performance Tips</a></li>
<li><a href="http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/">A Beginner’s Guide to Big O Notation</a></li>
</ul>


<p>Danke.</p>
]]></content>
  </entry>
  
</feed>
