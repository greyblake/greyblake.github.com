<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Sergey Potapov Online]]></title>
  <link href="http://greyblake.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://greyblake.com/"/>
  <updated>2012-07-15T23:28:12+03:00</updated>
  <id>http://greyblake.com/</id>
  <author>
    <name><![CDATA[Sergey Potapov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to build Vim against specific Ruby version]]></title>
    <link href="http://greyblake.com/blog/2012/07/15/how-to-build-vim-against-specific-ruby-version/"/>
    <updated>2012-07-15T23:00:00+03:00</updated>
    <id>http://greyblake.com/blog/2012/07/15/how-to-build-vim-against-specific-ruby-version</id>
    <content type="html"><![CDATA[<p>Let's say you installed your Vim editor as a system package. Likely it was compiled against Ruby 1.8.7.
But what if you need Vim compiled with Ruby 1.9.x?
I'm gonna tell you how to do it.</p>

<!--more-->


<h2>Clone vim repository</h2>

<p>Make sure you have installed <code>mercurial</code> package:</p>

<p><code>sh
$ sudo apt-get install mercurial
</code></p>

<p>Clone Vim repository from google code:</p>

<p><code>sh
$ hg clone https://vim.googlecode.com/hg/ vim_sources
$ cd vim_sources
</code></p>

<h2>Patching</h2>

<p>There is no option to specify Ruby version to compile Vim against.
But it's easy to patch vim sources to force it to use <code>1.9</code> instead of <code>1.8</code>.</p>

<p>Open file <code>src/Make_mvc.mak</code> in vim sources directory.</p>

<p>Find lines like this:</p>

<p>```make src/Make_mvc.mak</p>

<p>#</p>

<h1>Support Ruby interface</h1>

<p>#
!ifdef RUBY</p>

<h1>Set default value</h1>

<p>!ifndef RUBY_VER
RUBY_VER = 18
!endif
!ifndef RUBY_VER_LONG
RUBY_VER_LONG = 1.8
!endif</p>

<p>```</p>

<p>Replace <code>18</code> and <code>1.8</code> with <code>19</code> and <code>1.9</code>. So it should look this way:</p>

<p>```make src/Make_mvc.mak</p>

<p>#</p>

<h1>Support Ruby interface</h1>

<p>#
!ifdef RUBY</p>

<h1>Set default value</h1>

<p>!ifndef RUBY_VER
RUBY_VER = 19
!endif
!ifndef RUBY_VER_LONG
RUBY_VER_LONG = 1.9
!endif</p>

<p>```</p>

<h2>Configure and compile</h2>

<p>At first make sure your current ruby version is which one you need:</p>

<p><code>sh
$ rvm use 1.9.3 --default
$ ruby -v
ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-linux]
</code></p>

<p>No we are ready to run <code>./configure</code> script:</p>

<p><code>sh
$ ./configure --enable-rubyinterp=yes --prefix=/where/you/want/ruby/to/be/installed/
</code></p>

<p>If everything is OK we can go ahead and compile it:</p>

<p><code>sh
$ make -j 3
</code></p>

<p><code>-j</code> option defines number of processes to make builing faster. It's useful if number of CPU cores is greater than one.</p>

<p>Finally install built Vim to <code>/where/you/want/ruby/to/be/installed/</code> directory which you passed as <code>--prefix</code> option:</p>

<p><code>sh
$ make install
</code></p>

<h2>Verify Ruby version</h2>

<p>Now let's open your new Vim:</p>

<p><code>sh
$ cd /where/you/want/ruby/to/be/installed/
$ ./bin/vim
</code></p>

<p>And run the next command:</p>

<p><code>vim
:ruby puts RUBY_DESCRIPTION
</code></p>

<p>The ouput should looks similar to this:</p>

<p><code>
ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-linux]
</code></p>

<p>So, everything is OK. Enjoy Vim and builtin ruby 1.9 ;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Тестируем вложенные ActiveRecord-модели с RSpec]]></title>
    <link href="http://greyblake.com/blog/2012/07/06/tiestiruiem-vlojenie-activerecord-modeli-s-rspec/"/>
    <updated>2012-07-06T22:19:00+03:00</updated>
    <id>http://greyblake.com/blog/2012/07/06/tiestiruiem-vlojenie-activerecord-modeli-s-rspec</id>
    <content type="html"><![CDATA[<p>Иногда бывает так, что вам нужно построить большой граф вложенных объектов,
и конечно же протестировать, что ваш "builder" работает так, как нужно. На самом деле
задача элементарная, но я всё же попробую поискать наиболее элегантный путь её решения.</p>

<!--more-->


<p>Расмотрим следующий пример, когда у нас есть три небольшие модели: User, Account, Preference.
(На практике обычно моделей намного больше с большим количеством свойств).</p>

<p>```ruby user.rb
class User &lt; ActiveRecord::Base
  attr_accessible :last_name, :first_name</p>

<p>  has_one :account
end
```</p>

<p>```ruby account.rb
class Account &lt; ActiveRecord::Base
  attr_accessible :email, :last_visit_date</p>

<p>  belongs_to :user
  has_one :preference
end
```</p>

<p>```ruby preference.rb
class Preference &lt; ActiveRecord::Base
  attr_accessible :language, :weapon</p>

<p>  belongs_to :user
end
```</p>

<p>Предположим у нас есть некий builder, который строит объект User и все завимимые
модели(Account и Preference). Всё что мы хотим сделать - это протестировать,
что граф объектов построен правильно.</p>

<p>Вот пример реализации стандартного rspec-теста, который первым приходит на ум:</p>

<p>```ruby user_builder_spec.rb
describe UserBuilder do
  describe '#build' do</p>

<pre><code>describe 'user' do
  let(:user) { described_class.new(some_attrs).build }
  subject { user }

  its(:first_name) { should == "Rodion"      }
  its(:last_name)  { should == "Raskolnikov" }

  describe 'account' do
    subject { user.account }

    its(:email)           { should == "rodion@mail.ru"       }
    its(:last_visit_date) { should == Date.new(1866, 11, 27) }

    describe 'preference' do
      subject { user.account.preference }

      its(:language) { should == "Russian" }
      its(:weapon)   { should == "ax"      }
    end
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Всё читаемо, красиво и просто. Но проблема в том, что получилось шесть тестов(по тесту на
каждый атрибут), которые тестируют лишь одно действие - постороение объекта. Когда операция построения
занимает немало времени, а количество атрибутов на порядок больше, такой подход
становится далеко не самым лучшим, поскольку возрастает время выполнения.
Если объект не сохраняется в базе то вполне разумным будет использовать <code>before :all</code>. Но если
вам приходится сохранять объект и вы используете опцию <code>config.use_transactional_fixtures = true</code>,
потому что не хотите "гадить" в базу, то этот вариант не подойдёт.</p>

<p>Можно пойти по пути классического unit-тестирования и сделать тест подобным этому:</p>

<p>```ruby user_builder_spec.rb
describe UserBuilder do
  describe '#build' do</p>

<pre><code>let(:user) { described_class.new(some_attrs).build }

it 'should correctly build a user' do
  user.first_name.should == "Rodion"
  user.last_name.should  == "Raskolnikov"
  user.account.email.should           == "rodion@mail.ru"
  user.account.last_visit_date.should == Date.new(1866, 11, 27)
  user.account.preference.language.should == "Russian"
  user.account.preference.weapon.should   == "ax"
end
</code></pre>

<p>  end
end
```</p>

<p>Получилось даже лаконичнее, но менее читаемо(уж когда будет больше вложенность объектов,
будет точно менее читаемо). Так же раздрожает длинные цепочки одинаковых методов.</p>

<p>Помедитировав над проблемой, я нашёл компроммиссное решение на основе метода <code>instance_eval</code>.</p>

<p>```ruby user_builder_spec.rb
describe UserBuilder do
  describe '#build' do</p>

<pre><code>let(:user) { described_class.new(some_attrs).build }

it 'should correctly build a user' do
  user.instance_eval do
    first_name.should == "Rodion"
    last_name.should  == "Raskolnikov"

    account.instance_eval do
      email.should           == "rodion@mail.ru"
      last_visit_date.should == Date.new(1866, 11, 27)

      preference.instance_eval do
        language.should == "Russian"
        weapon.should   == "ax"
      end
    end
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Это по-прежнему один тест, но мы избавились от длинных цепочек методов.
Нужно заметить, что у такого подхода есть тоже свои недостатки: используя <code>instance_eval</code>
мы покидаем контекст теста, и переходим прямо в контекст объекта, в котором не существует методов подобных
<code>be_valid</code>, <code>be_instance_of</code>, etc.</p>

<p>Надеюсь, эта идея будет вам полезной. Буду рад узнать чужое мнение.</p>
]]></content>
  </entry>
  
</feed>
